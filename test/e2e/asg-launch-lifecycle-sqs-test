#!/bin/bash
set -euo pipefail

REGION="us-west-2"
CLUSTER_NAME="nth-eks-cluster-test"

node_group_name="nth-eks-cluster-test-spot-ng"
sqs_queue_name="nth-sqs-test"
sns_topic_name="nth-sns-test"
auto_scaling_role_name="AWSServiceRoleForAutoScaling_nth-test"
auto_scaling_policy_arn="arn:aws:iam::aws:policy/aws-service-role/AutoScalingServiceRolePolicy"
fis_role_name="nth-test-fis-role"
fis_template_name="nth-fis-test"
fis_policy_arn="arn:aws:iam::aws:policy/service-role/AWSFaultInjectionSimulatorEC2Access"
SCRIPTPATH="$( cd "$(dirname "$0")" ; pwd -P )"
NODE_GROUP_CONFIG_FILE="$SCRIPTPATH/../eks-cluster-test/node_group-spec.yaml"
account_id=$(aws sts get-caller-identity | jq -r '.Account')
nth_label="Use-Case=NTH"


## Queue Policy
QUEUE_POLICY=$(cat <<EOF
{
    "Version": "2012-10-17",
    "Id": "MyQueuePolicy",
    "Statement": [{
        "Effect": "Allow",
        "Principal": {
            "Service": ["events.amazonaws.com", "sqs.amazonaws.com"]
        },
        "Action": "sqs:SendMessage",
        "Resource": [
            "arn:aws:sqs:${REGION}:${account_id}:${sqs_queue_name}"
        ]
    }]
}
EOF
)

function create_queue {
    cat << EOF > /tmp/queue-attributes.json
{
"MessageRetentionPeriod": "300",
"Policy": "$(echo $QUEUE_POLICY | sed 's/\"/\\"/g' | tr -d -s '\n' " ")",
"SqsManagedSseEnabled": "true"
}
EOF

queue_url=$(aws sqs create-queue --queue-name "${sqs_queue_name}" --attributes file:///tmp/queue-attributes.json | jq -r .QueueUrl)
}

function provision_sqs_queue {
    queue_exists=$(aws sqs list-queues --queue-name-prefix $sqs_queue_name)
    if [[ -z $queue_exists ]]; then
        echo "🥑 Provisioning SQS Queue"
        create_queue
    else 
        echo "🥑 $sqs_queue_name already exists; continuing with test run"
        queue_url=$(aws sqs list-queues --queue-name-prefix $sqs_queue_name | jq -r '.QueueUrls | .[0]')
    fi
    
    echo "Queue URL: $queue_url"
    sqs_arn=$(aws sqs get-queue-attributes --queue-url=$queue_url --attribute-names=QueueArn | jq -r .Attributes.QueueArn)
}

function provision_sns_topic {
    topic_exists=$(aws sns list-topics | grep "$sns_topic_name" || :)
    if [[ -z $topic_exists ]]; then
        echo "🥑 Provisioning SNS Topic"
        sns_arn=$(aws sns create-topic --name $sns_topic_name | jq -r .TopicArn)
    else 
        echo "🥑 $sns_topic_name already exists; continuing with test run"
        sns_arn=$(aws sns list-topics | jq -r '.Topics | .[] | .TopicArn' | grep "nth-sns-test")
    fi
    echo "SNS ARN: $sns_arn"
}

function subscribe_sqs_to_sns {
    num_subscriptions=$(aws sns list-subscriptions-by-topic --topic-arn $sns_arn | jq '.Subscriptions | length')
    if [[ $num_subscriptions -eq 0 ]]; then
        echo "🥑 Subscribing $sns_topic_name to $sqs_queue_name"
        aws sns subscribe --topic-arn $sns_arn --protocol sqs --notification-endpoint $sqs_arn
    else 
        echo "🥑 $sns_topic_name already subscribed to $sqs_queue_name; continuing with test run"
    fi
}

function install_helm {
    anth_helm_args=(
        upgrade
        --install
        --namespace kube-system
        "$CLUSTER_NAME-acth"
        "$SCRIPTPATH/../../config/helm/aws-node-termination-handler/"
        --set image.repository="$NODE_TERMINATION_HANDLER_DOCKER_REPO"
        --set image.tag="$NODE_TERMINATION_HANDLER_DOCKER_TAG"
        --set image.pullPolicy="Always"
        --set nodeSelector."${nth_label}"
        --set tolerations[0].operator=Exists
        --set awsAccessKeyID=foo
        --set awsSecretAccessKey=bar
        --set awsRegion="${REGION}"
        --set checkTagBeforeDraining=false
        --set enableSqsTerminationDraining=true
        --set queueURL="${queue_url}"
        --wait
    )

    set -x
    helm "${anth_helm_args[@]}"
    set +x

    sleep 15
}

function provision_node_group {
    node_group_exists=$(eksctl get nodegroup --cluster=$CLUSTER_NAME --name $node_group_name || :)
    if [[ -z $node_group_exists ]]; then
        echo "🥑 Provisioning Spot Node Group"
    else 
        echo "🥑 Re-initializing $node_group_name for testing purposes"
        eksctl delete nodegroup -f $NODE_GROUP_CONFIG_FILE --approve
        echo ""

        node_group_exists=$(eksctl get nodegroup --cluster=$CLUSTER_NAME --name $node_group_name || :)
        echo -n "Node group Deleting."
        while [[ -n $node_group_exists ]]; do
            echo -n "."
            node_group_exists=$(eksctl get nodegroup --cluster=$CLUSTER_NAME --name $node_group_name || :)
            sleep 10
        done
        echo ""
        sleep 20
        # asg_name=$(eksctl get nodegroup --cluster=$CLUSTER_NAME --name=$node_group_name --output=json | jq -r '.[0].AutoScalingGroupName')
    fi

    eksctl create nodegroup --config-file=$NODE_GROUP_CONFIG_FILE
    update_ASG

    instance_ids=$(aws autoscaling describe-auto-scaling-groups --auto-scaling-group-names $asg_name | jq -r '.AutoScalingGroups | .[0].Instances | .[].InstanceId')
    instance_data=$(aws ec2 describe-instances --instance-ids $instance_ids | jq -r '[.Reservations | .[] | .Instances | .[].InstanceId, .[].PrivateDnsName]')

    nth_node_id=$(jq -r '.[0]' <<< $instance_data)
    nth_node_ip=$(jq -r '.[1]' <<< $instance_data)
    termination_node_id=$(jq -r '.[2]' <<< $instance_data)
    termination_node_ip=$(jq -r '.[3]' <<< $instance_data)

    kubectl label nodes $nth_node_ip $nth_label
}

function update_ASG {
    asg_name=$(eksctl get nodegroup --cluster=$CLUSTER_NAME --name=$node_group_name --output=json | jq -r '.[0].AutoScalingGroupName')
    echo "Auto Scaling Group: $asg_name"

    echo "🥑 Setting Capacity Rebalance"
    aws autoscaling update-auto-scaling-group --auto-scaling-group-name $asg_name --capacity-rebalance
    echo "🥑 Tagging ASG"
    aws autoscaling create-or-update-tags --tags ResourceId=$asg_name,ResourceType=auto-scaling-group,Key=aws-node-termination-handler/managed,Value=,PropagateAtLaunch=true

    create_auto_scaling_role
    echo "🥑 Creating Lifecycle Hooks"
    aws autoscaling put-lifecycle-hook --lifecycle-hook-name "Launch-LC-Hook" --auto-scaling-group-name $asg_name --lifecycle-transition="autoscaling:EC2_INSTANCE_LAUNCHING" --heartbeat-timeout=180 --notification-target-arn=$sns_arn --role-arn=$auto_scaling_role_arn --default-result="ABANDON"     
    aws autoscaling put-lifecycle-hook --lifecycle-hook-name "Terminate-LC-Hook" --auto-scaling-group-name $asg_name --lifecycle-transition="autoscaling:EC2_INSTANCE_TERMINATING" --heartbeat-timeout=180 --notification-target-arn=$sns_arn --role-arn=$auto_scaling_role_arn --default-result="CONTINUE"
}

function create_auto_scaling_role {
    auto_scaling_role_exists=$(aws iam get-role --role-name=$auto_scaling_role_name | grep "$auto_scaling_role_name" || :)
    if [[ -z $auto_scaling_role_exists ]]; then
        echo "🥑 Creating Auto Scaling Role"
        auto_scaling_role_arn=$(aws iam create-service-linked-role --aws-service-name autoscaling.amazonaws.com --custom-suffix "nth-test" | jq -r '.Role.Arn')
        sleep 10
    else
        echo "🥑 $auto_scaling_role_name already exists; continuing with test run"
        auto_scaling_role_arn=$(aws iam get-role --role-name=$auto_scaling_role_name | jq -r '.Role.Arn')
    fi
}

function create_FIS_role {
    fis_role_exists=$(aws iam get-role --role-name $fis_role_name | grep "$fis_role_name" || :)
    if [[ -z $fis_role_exists ]]; then
        cat << EOF > /tmp/fis-role-trust-policy.json
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Principal": {
                "Service": [
                "fis.amazonaws.com"
                ]
            },
            "Action": "sts:AssumeRole"
        }
    ]
}
EOF
        echo "🥑 Creating FIS Role"
        fis_role_arn=$(aws iam create-role --role-name $fis_role_name --assume-role-policy-document file:///tmp/fis-role-trust-policy.json | jq -r '.Role.Arn')
        aws iam attach-role-policy --role-name $fis_role_name --policy-arn $fis_policy_arn
        sleep 10
    else
        echo "🥑 $fis_role_name already exists; continuing with test run"
        fis_role_arn=$(aws iam get-role --role-name=$fis_role_name | jq -r '.Role.Arn')
    fi
}

function create_experiment_template {
    experiment_exists=$(aws fis list-experiment-templates | grep "$fis_template_name" || :)
    if [[ -z $experiment_exists ]]; then
        create_FIS_role
        cat << EOF > /tmp/fis-experiment-template.json
{
    "description": "Test Spot Instance interruptions",
    "targets": {
        "oneSpotInstance": {
            "resourceType": "aws:ec2:spot-instance",
            "resourceTags": {
                "Name": "interruptMe"
            },
            "filters": [
                {
                    "path": "State.Name",
                    "values": [
                        "running"
                    ]
                }
            ],
            "selectionMode": "COUNT(1)"
        }
    },
    "actions": {
        "interruptSpotInstance": {
            "actionId": "aws:ec2:send-spot-instance-interruptions",
            "parameters": {
                "durationBeforeInterruption": "PT2M"
            },
            "targets": {
                "SpotInstances": "oneSpotInstance"
            }
        }
    },
    "stopConditions": [
        {
            "source": "none"
        }
    ],
    "roleArn": "$fis_role_arn",
    "tags": {
        "Name": "$fis_template_name"
    }
}
EOF
        echo "🥑 Creating experiment template"
        template_id=$(aws fis create-experiment-template --cli-input-json file:///tmp/fis-experiment-template.json | jq -r .experimentTemplate.id)
        echo "Template_ID: $template_id"
    else
        template_id=$(aws fis list-experiment-templates | jq -r --arg template_name $fis_template_name '.experimentTemplates | .[] | select(.tags | has("Name")) | select(.tags.Name | contains($template_name)) | .id')
        echo "🥑 $fis_template_name already exists; continuing with test run"
    fi
}

function start_FIS_experiment {
    create_experiment_template
    echo "🥑 Starting Experiment"
    experiment_start_time=$(aws fis start-experiment --experiment-template-id $template_id | jq -r '.experiment.startTime')
}

function create_tags {
    echo "🥑 Creating instance tags"
    instance_id_string=$(tr '\n' ' ' <<< ${instance_ids})
    eval 'aws ec2 create-tags --resources'" $instance_id_string "'--tags 'Key="aws-node-termination-handler/managed",Value=''
    aws ec2 create-tags --resources "${termination_node_id}" --tags Key=Name,Value=interruptMe
}

function is_new_instance {
    is_new_instance=""
    if [[ $instance_ids =~ (^|[[:space:]])$1($|[[:space:]]) ]]; then
        is_new_instance=false
    else 
        is_new_instance=""
    fi
}

function get_launch_activity {
    launch_activity=""
    while [[ -z $launch_activity  ]]; do
        sleep 5
        activities=$(aws autoscaling describe-scaling-activities --auto-scaling-group-name $asg_name)
        activities_details=$(jq -r '[.Activities | .[] | .ActivityId, .Description, .StatusCode]' <<< $activities)
        num_activities=$(jq -r 'length' <<< $activities_details)
        for i in $(seq 0 3 $((--num_activities))); do
            id=$(jq -r .[$i] <<< $activities_details)
            description=$(jq -r .[$((++i))] <<< $activities_details)
            status=$(jq -r .[$((i+=2))] <<< $activities_details)
            activity_instance=${description##*:}
            is_new_instance $activity_instance
            if [[ $description =~ .*"Launching".* && -z $is_new_instance ]]; then
                launch_activity=$id
                echo "🥑 Launch Activity found for instance $activity_instance"
                break
            fi    
        done
    done
}

function test_launch_lifecycle {
    echo -n "🥑 Waiting for launch hook completion."
    while [[ true ]]; do
        activity_status=$(aws autoscaling describe-scaling-activities --auto-scaling-group-name $asg_name --activity-ids $launch_activity | jq -r '.Activities | .[] | .StatusCode')
        if [[ $activity_status == "Success" ]]; then
            echo ""
            echo "✅ Launch Lifecycle Successfully Completed ✅"
            # exit 0
            break
        fi

        if [[ $activity_status == "Cancelled" ]]; then
            echo ""
            echo "❌ Launch Lifecycle Failed ❌"
            # exit 1
            break
        fi
        echo -n "."
        sleep 10
    done
}

function clean_up {
    echo "====================================================================================================="
    echo "🧹  Cleaning up SQS, SNS, NodeGroup, IAM, FIS  🧹"
    echo "====================================================================================================="
    helm uninstall nth-eks-cluster-test-acth -n kube-system
    eksctl delete nodegroup -f $NODE_GROUP_CONFIG_FILE --approve
    aws sqs delete-queue --queue-url $queue_url
    aws sns delete-topic --topic-arn $sns_arn
    deletedTemplate=$(aws fis delete-experiment-template --id $template_id --no-paginate)
    aws iam detach-role-policy --role-name $fis_role_name --policy-arn $fis_policy_arn
    aws iam delete-role --role-name $fis_role_name
    aws iam delete-service-linked-role --role-name $auto_scaling_role_name
}

function main {
    provision_sqs_queue
    provision_sns_topic
    subscribe_sqs_to_sns
    provision_node_group
    install_helm
    create_tags
    start_FIS_experiment
    get_launch_activity
    test_launch_lifecycle
}

main
trap "clean_up" EXIT
